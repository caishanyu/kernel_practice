# 字符设备驱动

TOC

- [字符设备驱动](#字符设备驱动)
  - [一些前提知识](#一些前提知识)
  - [字符设备](#字符设备)
  - [设备创建](#设备创建)
    - [字符设备注册和注销](#字符设备注册和注销)

## 一些前提知识

外设的寄存器只能由linux内核访问，只有内核能够收集外设捕获的数据流

Linux需要一种能够将数据从内核态传给用户态的机制，之中数据的传输通过**设备节点**来处理，也称为**虚拟文件**。设备节点存在于根文件系统中，并不是真正的文件

用户读取设备节点时，内核将底层驱动捕获的数据流拷贝到应用程序的内存空间；用户写设备节点时，内核将应用程序提供的数据流拷贝到驱动程序的数据缓冲区。

虚拟文件可以被用户程序通过标准的**系统调用**方式打开、读取或写入

用户程序的请求最终被送往驱动核心，每个设备都有专门驱动来处理请求。Linux支持三种设备：**字符设备、块设备和网络设备**，每种设备在驱动上的差异主要体现在文件的打开、读取和写入行为。

1. 字符设备是最常见的设备，这种设备的读写直接进行而无需经过缓冲区，比如键盘、显示器、打印机、串口
2. 块设备的读写以块为单位，一次读写整数倍的块大小，可以随机读写任何块，例如硬盘驱动器
3. 网络设备通过BSD套接字接口和网络子系统访问

## 字符设备

从应用程序的角度看，字符设备本质上就是一个文件。进程只知道一个`/dev`文件路径

用户进程通过`open()`系统调用来打开文件，通过`read()`和`write()`来执行标准的文件读写

为此，字符设备驱动必须实现`file_operations`数据结构中秒数的各种操作，并且注册

linux文件系统层负责确保调用驱动相关的操作，用户态程序执行对应系统调用时触发，内核驱动负责实现并注册回调

（比如用户程序调用`read()`，会调用驱动实现的`read()`）

![fs](https://github.com/caishanyu/notes/blob/main/images/fs.png)

内核驱动通过`copy_from_user()`和`copy_to_user()`与用户态程序交换数据

在linux中，设备通过两个设备号来表示：主设备号和从设备号。可以通过`ls -l/dev`查看

设备驱动将自己的主设备号注册到内核，并负责管理从设备号。当访问一个设备文件时，主设备号决定了执行输入/输出操作时调用哪个设备驱动，从设备号的使用则取决于具体设备，由驱动负责管理。

比如一个设备有多个UART口，同样的驱动被用来控制所有UART设备，但每个物理节点都需要由自己的设备节点

## 设备创建

linux设备创建可以通过静态方式，在终端使用`mknod`，在`/dev/`目录下创建设备，比如

```bash
mknod /dev/mydev c 202 108
# 设备节点名称 设备类型 major minor
```

更佳的创建方式是，使用**设备文件系统**和**杂项框架**，后边再使用

### 字符设备注册和注销

字符设备的注册和注销通过指定主从设备号实现，`dev_t`类型用于保存这两个属性，该类型的变量可以通过`MKDEV(major, minor)`宏来获取

静态分配与释放分别使用：

```c
int register_chrdev_region(dev_t first, unsigned int count, char *name)
void unregister_chr_dev_region(dev_t first, unsigned int count)
```

实践中比较推荐**动态分配**

```c
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, 
    unsigned count, const char *name)
```

其中`dev`作为返回参数，`baseminor`为起始从设备号，`count`为申请的设备数量

分配完设备号后，使用`cdev_init()`注册初始化字符设备；使用`cdev_add()`注册到内核；使用`cdev_del()`注销设备